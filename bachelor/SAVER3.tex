% !TEX root = ../Thesis.tex
\chapter{The PINCH Method}

Now that we have laid a foundation, let us talk about the main topic of this thesis, the Prioritized INCremental Heuristic (PINCH). PINCH was introduced by Yaxin Liu, Sven Koenig and David Furcy in their 2002 paper "Speeding Up the Calculation of Heuristics for Heuristic Search-Based Planning". It is a method for calculating $h^a^d^d$ that combines the previously introduced Generalized Dijkstra Algorithm with the Incremental Value Iteration approach.


\section{PINCH, The Best of Both Worlds}
\label{sec:my-label}

Previously we have discussed two methods for computing $h^a^d^d$, Generalized Dijkstra (GD) and Incremental Value Iteration (IVI). Both methods come with their strengths and weaknesses. GD is very efficient at computing $h^a^d^d$ for a single state, but in the larger context of an entire state space GD doesn't make use of previously calculated $h^a^d^d$ values. In other words, GD treats each state as its own entity, it doesn't take into consideration the similarities certain states might share. IVI methods account for similarities between different states, they remember the previously annotated $h^a^d^d$ cost values but they are considerably worse at evaluating a single state when compared to GD. Another way of thinking about it is that IVI methods take a holistic approach, they consider, as best they can, information from the entire state space. GD takes a reductionist approach, its focus is solely on one state an makes its computation as efficient as possible. \\

PINCH aims to combine the strengths of both GD and IVI. This is a non trivial task as the differences between GD and IVI methods appear in many ways irreconcilable. GD makes the fundamental assumption that cost values cannot increase during the computation of heuristic values, IVI methods violate this property. To show how PINCH works we will look at the pseudo code for PINCH and work through the algorithm step by step. Following is the pseudo code for PINCH.\\
\begin{center}
\resizebox{13.5cm}{!}{
\begin{algorithm*}[H]
\SetKwFunction{FVI}{AdjustVariable}
\SetKwProg{Pn}{Function}{:}{}
%\SetAlgoLined
%\KwResult{Write here the result }
\Pn{\FVI{$q$}}{
\eIf{$q \in V$}{
\eIf{$q \in s$}{
set $rhs_q := 0$\;
} {
set $rhs_q := \text{min}_a_\in_A_|_v_\in_a_d_d_(_a_) [cost(a) + x_a]$\;
}
} {
/*$q \in A$*/ \\
set $rhs_q := cost(a) + \sum_{v \in pre(a)}^{} x_v$\;
}
\If{$q$ is in the priority queue}{
delete it\;
}
\If{$x_q \neq rhs_q$}{
insert $q$ into the priority queue with priority min($x_q,rhs_q$)\;
}
}
\BlankLine
\BlankLine
\SetKwFunction{FVI}{SolveEquations}
\Pn{\FVI{}}{
\While{the priority queue is not empty}{
delete the element with the smallest priority from the queue and assign it to $q$\;
\eIf{$rhs_q < x_q$}{
set $x_q := rhs_q$\;
\uIf{$q \in V$}{
for each $a \in A$ such that $q \in pre(a)$ do AdjustVariable($a$)\;
}
\uElseIf{$q \in A$}{
for each $v \in add(q)$ with $v \notin s$ do AdjustVariable($v$)\;
}
}{
set $x_q := \infty$\;
AdjustVariable($q$)\;
\uIf{$q \in V$}{
for each $a \in A$ such that $q \in pre(a)$ do AdjustVariable($a$)\;
}
\uElseIf{$q \in A$}{
for each $v \in add(q)$ with $v \notin s$ do AdjustVariable($v$)\;
}
}
}
} 
\BlankLine
\BlankLine
\SetKwFunction{FVI}{PINCH}
\SetKwBlock{Do}{forever do}{}
\Pn{\FVI{state s}}{
\eIf{s is initial state}{
empty the priority queue\;
\ForEach{$q \in V \cup A$}{set $x_q := \infty$\;}
\ForEach{$q \in V \cup A$}{AdjustVariable($q$)\;}
} {
\ForEach{$v \in (s \setminus s') \cup (s' \setminus s)$}{
AdjustVariable($v$)\;
}
}
SolveEquations()\;
set $s' := s$\;
\KwRet 1/2 $\sum_{v \in G}^{} x_v$\;
}
 
 
 
 \caption{PINCH}
\end{algorithm*}\\
}
\end{center}

\newpage
\section{The Algorithm in Depth}
I want to explain PINCH by taking the algorithm through an example. Lets consider the following planning task $\Pi^+ = \langle V, I, G, A \rangle$ with:

\begin{center}
\begin{multicols}{2}
\begin{itemize}
\setlength\itemsep{0em}
\item $V = \{a,b,c,d,e,f,g,h\}$
\item $I = \{a,b\}$
\item $G = \{c,d,e,f,g\}$ 
\item $A = \{a_1,a_2,a_3,a_4,a_5,a_6\}$
\item $a_1 = a \xrightarrow[\text{}]{\text{3}} b,c$
\item $a_2 = a,c \xrightarrow[\text{}]{\text{1}} d$
\item $a_3 = b,c \xrightarrow[\text{}]{\text{1}} e$
\item $a_4 = b \xrightarrow[\text{}]{\text{1}} f$
\item $a_5 = d \xrightarrow[\text{}]{\text{1}} e,f$
\item $a_6 = d \xrightarrow[\text{}]{\text{1}} g$
\end{itemize}
\end{multicols}
\end{center}
We will compute PINCH($s$) for the current state $s$. For the computation PINCH will use information from the previous state $s'$. $s$ and $s'$ are defined as follows: 
\begin{center}
\begin{multicols}{2}
\begin{itemize}
\setlength\itemsep{0em}
\item $s' = I = \{a,b\}$
\item $s = \{a,c\}$
\end{itemize}
\end{multicols}
\end{center}
Since PINCH is an incremental algorithm the cost values of $s'$ are relevant for the computation of $s$, therefore lets take a look at $s'$:
\input{RPG_a_b_solved}
In the table on the right you will find the annotated cost values $x_q$ for all $q \in V \cup A$, you will also find a column for a property named $rhs_q$, we will explain the utility of this property as we go along. On the left you see the relaxed planning graph (RPG) for $s'$. PINCH does not build a RPG but this visualization will help us understand the algorithm.\\

You may have noticed that the annotated cost values aren't calculated the way that was introduced in equations (2.1) and (2.2), this is because PINCH changes these equations as follows:
\newpage
\begin{equation}
 g'_s(v) = 
  \begin{cases} 
   0 & \text{if } v \in s \\
   \text{min}_a_\in_A_|_v_\in_a_d_d_(_a_) [cost(a) + g'_s(a)]       & \text{otherwise } 
  \end{cases}
\end{equation}

\begin{equation}
    g'_s(a) = cost(a) + \sum_{v \in pre(a)}^{} g'_s(v)
\end{equation}

It is trivial to show that $g_s(v) =$ 1/2 $g'_s(v)$ and therefore $h^a^d^d(s) = \sum_{v \in G}^{} g_s(v)$ = $1/2 \sum_{v \in G}^{} g'_s(v)$. This version of PINCH works for planning tasks where for every $a \in A | cost(a) > 0$. It is an expansion of the PINCH algorithm introduce by Yaxin Liu and collegues 2002, which required for every $a \in A | cost(a) = 1$. The reason for PINCH changing these equations will become clear as we further explore the algorithm. \\

Starting with the algorithm, I want to focus on lines 38 and 39. Since $s$ is not the initial state this is where the algorithm begins. Here we call AdjustVariable($q$) for each $v \in (s \setminus s') \cup (s' \setminus s)$. In our example $ v \in (s \setminus s') = c$ and $v \in (s' \setminus s) = b$. Before we call AdjustVariable($q$) on $c$ and $b$, lets first take a look at the current state of our state s.
\input{s_start}
As you can see $s$ is currently an exact copy of $s'$. In PINCH we never reinitialize any $x_q$ to an arbitrary value, the $x_q$ values at the beginning of the computation of $s$ are therefore identical to its predecessor state $s'$. \\

Lines 1 - 13 in the pseudo code cover the AdjustVariable($q$) procedure. In this procedure the $rhs_q$ component is set according to equations (3.1) and (3.2) and the $q$ are inserted into the priority queue (PQ)  with value min($x_q, rhs_q$) if $x_q \neq rhs_q$. Here the utility of the $rhs_q$ component starts to show, $rhs_q$ is used to compare the current cost value of $q$, represented by $rhs_q$, with its previous cost value, represented by $x_q$. We have just updated $rhs_q$ and we only insert it into the PQ if $rhs_q \neq x_q$. Lets see what happens to $s$ after we call AdjustVariable($q$) on $b$ and $c$.
\newpage
\begin{center}
\resizebox{14cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{0pt}
\input{s_2}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{0.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $b$:0\\
     $c$:0\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}

The $rhs_q$ component of $b$ was set to 6 and the one of $c$ to 0. The RPG hasn't changed as it represents the $x_q$ and not the $rhs_q$. The numbers in red represent the $q$ whose values have changed compared to the previous picture. Additionally we now track the state of the priority queue, that currently holds $b$ and $c$ with value min($x_q, rhs_q$).  \\

Now we move on to Line 40 and therefore to the SolveEquations() procedure. This procedure spans from line 14 - 29 and makes up the majority of the algorithm. The main purpose of this procedure is to set the $x_q$ values and to call AdjustVariable($q$) on all the $q$ that are affected by the newly set $x_q$ values. The $q$ that are popped out of the PQ are treated based on the relationship between $rhs_q$ and $x_q$. \\

%Notice that PINCH, much like GD, heavily orders the value updates. By using the %priority queue PINCH updates

If $rhs_q > x_q$ then $x_q$ is set to $\infty$ and we call AdjustVariable($q$) for the current $q$ and all $q$ that follow from the current $q$. This is done because in this scenario we do not know the correct values for $x_q$ and therefore we dont know the values for all $q$ that depend on the current $q$.\\

if $rhs_q < x_q$ then $x_q$ is set to $rhs_q$. If this scenario occurs we know for certain that $rhs_q$ holds the correct value. This comparison of $x_q$ and $rhs_q$ in combination with the PQ is what allows PINCH to order value updates in a fashion similar to GD while also including incremental value calculations.\\

Let us take a look at our example after $b$ and $c$ were popped and processed in SolveEquations().

\newpage
\begin{center}
\resizebox{14cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{0pt}
\input{s_3}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{0.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $a_2$:1\\
     $a_4$:1\\
     $b$:6\\
     $a_3$:7\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}

Since the value of $b$ was set to $\infty$, we can now infer that everything that relies on $b$ might have to be recalculated. This is why the $rhs_q$ of $a_3$ and $a_4$ were set to $\infty$. The RPG represents the current state by having removed every node that depends on $b$ directly or indirectly.\\

The blue nodes in the RPG show us the incremental aspect of PINCH. Since $a$ was never inserted into the PQ, $a$ itself and all $q$ that solely depend on $a$ (In this case $a_1$) do not have to be recalculated. The green nodes show us those $q$ which PINCH had to recalculate and for which PINCH has set the final $x_q$ value. \\

If we now pop $a_2$ and process it the example looks as follows:


\begin{center}
\resizebox{14cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{0pt}
\input{s_4}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{0.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $a_4$:1\\
     $d$:2\\
     $b$:6\\
     $a_3$:7\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}
\newpage
We will now see how the algorithm progresses as we continue to process the $q$. This is the example after we pop $a4, d$:
\begin{center}
\resizebox{13cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{-30pt}
\input{s_5}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{-29.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $f$:2\\
     $a_5$:3\\
     $a_6$:3\\
     $b$:6\\
     $a_3$:7\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}
The example after we pop $f, a_5, a_6$:
\begin{center}
\resizebox{13cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{-30pt}
\input{s_6}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{-29.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $e$:4\\
     $f$:4\\
     $g$:4\\
     $b$:6\\
     $a_3$:7\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}
The example after we pop $e,f,g,b$:
\begin{center}
\resizebox{13cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{-30pt}
\input{s_7}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{-29.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     $a_4$:7\\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}
Interesting to note here is that the $rhs_q$ of $a_3$ was set to 7, which is the same as the cost value from the previous state. If $a_3$ had additional $q$ that solely rely on $a_3$, then PINCH would not recalculate the cost values for those $q$, meaning that the algorithm would once more benefit from the incremental calculations.
\newpage
The example after we pop $a_4$:
\begin{center}
\resizebox{13cm}{!}{
\begin{minipage}[t]{1\linewidth}
\vspace{-30pt}
\input{s_8}
\end{minipage}%
\begin{minipage}[t]{.15\linewidth}
\vspace{-29.5pt}
\begin{longtable}[c]{| c |}
     \hline
     \multicolumn{1}{| c |}{PQ}\\
     \hline
     \endfirsthead
     \hline
     \endfoot
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \\
     \hline
\end{longtable}
\end{minipage}%
}
\end{center}
The priority queue is now empty and therefore the SolveEquations() procedure is complete. PINCH now sets $h^a^d^d(s)$ = 1/2 $\sum_{v \in G}^{} x_v$. If we fill in the remaining no-op edges the final RPG looks as follows:
\input{RPG_a_c_solved}
PINCH will now set $s' = s$ which can be seen in Line 41 of the Algorithm. Now the next state is computed in the same fashion that we have just seen. Lines 31 - 36 set up PINCH for its first computation of the initial state $I$. Since there is no $s'$ in this instance, PINCH will treat the initial state $I$ in a fashion similar to GD.
\section{PINCH more formally}
\newpage
\section{Performance Hypothesis}
In the next section we will cover how PINCH stacks up against its non incremental counterpart GD, by comparing the two algorithms in a variety of domains. Before we compare the two algorithms, I want to hypothesis what kind of results we ought to expect.\\

The main difference between GD and PINCH is the incremental calculations that PINCH uses. Using incremental calculations comes at a cost however. GD is guaranteed to only update the cost value for each variable at most once, for PINCH this property changes to having to update the cost value for each variable at most twice \cite{main}.\\

I want to go over our example from the chapter 3.2 again but this time analyse how efficient PINCH is when computing said example. I also want to derive hypothesis for factors that should benefit PINCH from the example.\\

Now remember the final result of the Example from chapter 3.2 looks as follows:
\input{RPG_a_c_solved_inc}
The blue nodes tell us which $q$ did not have to be recalculated and were taken over from $s'$. In this example $s$ and $s'$ were set as follows:
\begin{center}
\begin{multicols}{2}
\begin{itemize}
\setlength\itemsep{0em}
\item $s' = I = \{a,b\}$
\item $s = \{a,c\}$
\end{itemize}
\end{multicols}
\end{center}
Now lets consider a new example with the same state space from chapter 3.2 but with:
\begin{center}
\begin{multicols}{2}
\begin{itemize}
\setlength\itemsep{0em}
\item $s' = \{a,b,c,d\}$
\item $s = \{a,b,c,d,e\}$
\end{itemize}
\end{multicols}
\end{center}
\newpage
The final result for $s'$ in this instance looks as follows:
\input{s_9}
The final result for $s$ in this instance looks as follows: 
\input{s_10}
As we can see the incremental benefit of PINCH appears to be much larger than in the previous example, i derive the following Hypothesis from this discovery:\\

\begin{center}
\textit{\textbf{Hypothesis 1:} PINCH benefits from state s and s' being as similar as possible.}\\
\textit{\textbf{Hypothesis 2:} PINCH benefits from state s and s' including a lot of variables in relation to the total number of variables}\\
\textit{\textbf{Hypothesis 3:} PINCH benefits from actions having a low number of preconditions.}
\end{center}
A further Hypothesis we can make is that PINCH is more likely to benefit from its incremental aspects if the number of preconditions for most actions is low (Hypothesis 3). You can see this in this example by looking at $a_1$ and $a_2$. For $a_1$ it is sufficient to reach variable $a$, so if $a$ is part of $s$ and $s'$ then we will not have to recalculate $a$ and $a_1$ for $s$. For $a_2$ we need to reach $a$ and $c$, meaning that it is more likely that we will have to recalculate $a_2$ rather than $a_1$ for $s$.


 